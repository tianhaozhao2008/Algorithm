这种一看题，求第n个xxx的，就是找递推公式了，可以动态规划找出状态转移方程，这题很难找，题解的状态转移方程乱得一批。
所以直接正着想，如果让你手写出来比如前20个丑数，你能找到什么规律来写：
首先第一个丑数是1，1可以派生出2、3、5这三个丑数，那么我们肯定选最小的2，
然后第二个丑数就是2了，此时1派生出的3和5还没用，然后2还可以乘2派生出4也没用（2*3与2*5的肯定比之前没用到的还大，所以先不考虑）
。。。
总之就是每次只比较三个数，分别是对应位置*2、对应位置*3、对应位置*5，选出来小的作为丑数，然后把对应位置++（如果对应位置*之后的值小于等于新的丑数的话）。
于是就是三个指针p2、p3、p5，初始都指向1这个丑数，新增了2之后，p2指向下一个丑数。。。（总之每个丑数都有机会轮到三个指针指向他，代表他将来*2、*3、*5组合出的新的丑数）
遍历一遍时间O（n），空间是长度为n的数组。

class Solution {
    public int nthUglyNumber(int n) {
        if(n<=0) return -1;
        int[]res=new int[n];
        res[0]=1;
        int p2=0; //p2是指要*2的下标。
        int p3=0;
        int p5=0;
        for(int i=1;i<res.length;i++){
            res[i]=Math.min(Math.min(2*res[p2],3*res[p3]),5*res[p5]); //取三个的最小值
            while(2*res[p2]<=res[i])p2++;
            while(3*res[p3]<=res[i])p3++;
            while(5*res[p5]<=res[i])p5++;
        }
        return res[res.length-1];
    }
}
